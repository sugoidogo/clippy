<!DOCTYPE html>
<body hidden>
    <div id="header">
        <img>
        <div>
            <h1 id="prefix"></h1>
            <h1 id="name"></h1>
        </div>
    </div>
    <video autoplay></video>
</body>
<style>

    body {
        width: 100vw;
        height: 100vh;
        margin: 0px;
        border: none;
    }

    div {
        display: flex;
    }

    img {
        height: 10vh;
        width: 10vh;
        border-radius: 50%;
        margin-right: 1vh;
    }

    h1 {
        font-family: Inter,Roobert,Helvetica Neue,Helvetica,Arial,sans-serif;
        color: blueviolet;
        font-size: 10vh;
        margin-top: 0px;
        margin-bottom: 0px;
        margin-right: 3vh;
        text-shadow: 
            1px 1px 5px black,
            -1px 1px 5px black,
            1px -1px 5px black,
            -1px -1px 5px black
        ;
    }

    video {
        width: 100vw;
        height: 90vh;
        object-fit: contain;
    }

</style>
<link rel="stylesheet">
<script>
    let pass, login, bid, commands, samegame, first, dur, cut, views, noreplay, autoplay, lastgame;
    let irc, gid, client_id, intervalID, tid;
    let queue = [];
    let history = [];
    let mods = [];
    const regex = /-preview-.*/g;
    const video = document.getElementsByTagName('video')[0];
    const body=document.getElementsByTagName('body')[0];
    const img=document.getElementsByTagName('img')[0];
    const name=document.getElementById('name');
    const css=document.getElementsByTagName('link')[0];
    const header=document.getElementById('prefix');

    function getURL(clip) {
        return clip['thumbnail_url'].replace(regex, '.mp4')
    }

    function fHistory(clip) {
        return !history.includes(getURL(clip));
    }

    function onplay() {
        body.hidden = false;
        if (cut) {
            tid = setTimeout(onended, cut * 1000);
        }
        if (autoplay) {
            queue.push(video.src);
        } else {
            history.push(video.src);
        }
    }

    function onended() {
        body.hidden = true;
        if (tid) {
            tid = clearTimeout(tid);
        }
        load(queue.shift());
    }

    function load(clip){
        video.src=null;
        if(!clip){
            return;
        }
        if(!autoplay){
            img.src=clip.img;
            name.innerHTML=clip.name;
        }
        video.src=clip.src;
    }

    function send(message) {
        console.log('< ' + message);
        irc.send(message);
    }

    function getMods() {
        send('PRIVMSG #' + login + ' :/mods')
    }

    function getAuthHeaders() {
        return {
            'Authorization': 'Bearer ' + pass
            , 'Client-Id': client_id
        }
    }

    async function getBroadcasterInfo(target) {
        target = target.toLowerCase();
        const response = await fetch('https://api.twitch.tv/helix/users'
            + '?login=' + target
            , {
                headers: getAuthHeaders()
            }
        )
        const json = await response.json()
        return json['data'][0];
    }

    async function getGame(bid) {
        const url = new URL('https://api.twitch.tv/helix/channels');
        url.search = new URLSearchParams({
            broadcaster_id: bid
        });
        const response = await fetch(url, {
            headers: getAuthHeaders()
        });
        const json = await response.json();
        console.log(json['data'][0]['game_id']);
        return json['data'][0]['game_id'];
    }

    function sameGame(clip) {
        console.log('clip gid '+clip['game_id']);
        return clip['game_id'] == gid;
    }

    function fDur(clip) {
        return clip['duration'] <= dur;
    }

    function shortest(clips) {
        let time = 61;
        for (clip of clips) {
            if (clip['duration'] < time) {
                time = clip['duration'];
            }
        }
        let trudur = dur;
        dur = time;
        clips = clips.filter(fDur);
        dur = trudur;
        return clips;
    }

    function fViews(clip) {
        return clip['view_count'] == views;
    }

    function mostViews(clips) {
        views = -1;
        for (clip of clips) {
            if (clip['view_count'] > views) {
                views = clip['view_count'];
            }
        }
        clips = clips.filter(fViews);
        views = true;
        return clips;
    }

    async function shoutout(target) {
        if (target[0] == '@') {
            target = target.substring(1);
        }
        console.log("! shoutout:" + target);
        target = await getBroadcasterInfo(target);
        const url = new URL('https://api.twitch.tv/helix/clips');
        const search = new URLSearchParams({
            broadcaster_id: target['id']
        });
        if (first) {
            search.append('first', first);
        }
        url.search = search;
        let response = await fetch(url, {
            headers: getAuthHeaders()
        });
        let json = await response.json();
        json = json['data'];
        if (noreplay) {
            let filtered = json.filter(fHistory);
            if (filtered.length != 0) {
                json = filtered;
            } else {
                history = [];
            }
        }
        if (samegame) {
            gid = await getGame(bid);
            let filtered = json.filter(sameGame);
            if (filtered.length != 0) {
                json = filtered;
            }
        }
        if (lastgame) {
            gid = await getGame(target['id']);
            let filtered = json.filter(sameGame);
            if (filtered.length != 0) {
                json = filtered;
            }
        }
        if (dur) {
            let filtered = json.filter(fDur);
            if (filtered.length != 0) {
                json = filtered;
            } else {
                json = shortest(json);
            }
        }
        if (views) {
            json = mostViews(json);
        }
        if (!autoplay) {
            let index = Math.floor(Math.random() * json.length);
            json = [json[index]];
        }

        let clips=[];
        for (clip of json){
            let info=await getBroadcasterInfo(clip['broadcaster_name']);
            clips.push({
                img:info['profile_image_url'],
                name:info['display_name'],
                src:getURL(clip)
            });
        }

        if (video.paused) {
            load(clips.shift())
        }
        queue=queue.concat(clips);
    }

    function onopen(event) {
        send('PASS oauth:' + pass)
        send('NICK ' + login)
        send('JOIN #' + login)
        send('CAP REQ :twitch.tv/commands')
        intervalID = setInterval(getMods, 1000)
    }

    async function onmessage(event) {
        const message = event.data;
        console.log('> ' + message)
        for (const line of message.split('\n')) {

            if (line.startsWith('PING')) {
                send('PONG' + line.substring(4))
                continue;
            }

            if (line.includes('The moderators of this channel are:')) {
                mods = line.substring(line.lastIndexOf(':') + 1).replaceAll(' ', '').split(',');
                mods.unshift(login);
                console.log('! mods list updated (' + mods.length + '):' + mods);
                continue;
            }

            for (const command of commands) {
                const user = line.substring(line.indexOf(':') + 1, line.indexOf('!'))
                if (mods.includes(user) && line.includes(command)) {
                    const target = line.substring(line.lastIndexOf(command) + command.length).trim();
                    await shoutout(target);
                }
            }
        }
    }

    function onerror(event) {
        clearInterval(intervalID);
        try {
            init();
            return;
        } catch (e) {
            console.error(event)
            console.error('when attempting to reconnect, another error occured')
            console.error(e)
        } finally {
            throw event
        }
    }

    function init() {
        const params = new URLSearchParams(document.location.search);
        pass = params.get('pass');
        login = params.get('login');
        client_id = params.get('client_id');
        getBroadcasterInfo(login).then((info)=>bid=info['id']);
        commands = params.get('commands').split(',');
        commands.pop();
        samegame = params.get('samegame') === 'true' || false;
        first = parseInt(params.get('first')) || null;
        dur = parseFloat(params.get('dur')) || null;
        cut = parseFloat(params.get('cut')) || null;
        views = params.get('views') === 'true' || false;
        noreplay = params.get('noreplay') === 'true' || false;
        autoplay = params.get('autoplay') === 'true' || false;
        lastgame = params.get('lastgame') === 'true' || false;
        css.href=params.get('css') || '';
        header.innerHTML=params.get('header') || '';
        const ircwsurl = params.get('ircwsurl') || 'wss://irc-ws.chat.twitch.tv:443'
        irc = new WebSocket(ircwsurl);
        irc.onopen = onopen;
        irc.onmessage = onmessage;
        irc.onerror = onerror;
        irc.onclose = onerror;
        video.onplay = onplay;
        video.onended = onended;
        if (autoplay) {
            shoutout(login);
        }
    }

    try {
        init();
    } catch (e) {
        alert(e);
        throw e;
    }

</script>