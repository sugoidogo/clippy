<h1>Clippy</h1>
<h3>Don't show this browser window on stream</h2>
    <h4 id="status">Loading...</h4>
    <button hidden id="obsAuth">Connect to OBS</button>
    <button hidden id="twitchAuth">Connect to Twitch</button>
    <div hidden id="config">
        <select id="instance"></select>
        <button id="refreshInputs">refresh</button>
        <div id="new" hidden>
            <label>
                Scene:
                <select id="sceneSelect"></select>
            </label><button id="refreshScenes">refresh</button><br>
            <label>
                Name:
                <input type="text" id="name" value="clippy">
            </label><br>
            <button id="createNewInstance">Create</button>
        </div>
        <div id="existing" hidden>
            <button id="deleteInstance">delete this instance</button><br>
            <label>
                <input type="checkbox" id="autoplay" class="config">
                Auto-play clips from my channel
            </label><br>
            <label>
                <input type="checkbox" id="autoso" class="config">
                Auto-shoutout users that raid me
            </label><br>
            <input type="text" id="newCommand">
            <button id="addNewCommand">Add Command</button>
            <br>
            <ul id="commands" class="config"></ul><br>
            <label>
                <input type="checkbox" id="messageOn" class="config">
                Send a message in chat (you can use
                <a target="_blank"
                    href="https://dev.twitch.tv/docs/api/reference#get-users:~:text=login%3D%3Clogin%20name%3E...-,Response%20Fields,-Field">
                    these variables
                </a>)
            </label><br>
            <textarea id="message" class="config"></textarea><br>
            <label>
                Search the last
                <input type="number" min="1" max="100" value="20" id="first" class="config">
                clips
            </label><br>
            <label>
                Add new filter:
                <select id="filterSelector">
                    <option value="single">single clip</option>
                    <option value="history">history</option>
                    <option value="category">category</option>
                    <option value="length">length</option>
                </select>
                <button id="addFilter">add</button>
            </label>
            <ol id="filters" class="config"></ol><br>
            <label>
                Header text (you can use
                <a target="_blank"
                    href="https://dev.twitch.tv/docs/api/reference#get-clips:~:text=the%20started_at%20value.-,Response%20Fields,-Field">
                    these variables
                </a>
                )<br>
                <input type="text" id="header" class="config">
            </label><br>
            <span>
                Footer text (you can use
                <a target="_blank"
                    href="https://dev.twitch.tv/docs/api/reference#get-clips:~:text=the%20started_at%20value.-,Response%20Fields,-Field">
                    these variables
                </a>
                )
            </span><br>
            <input type="text" id="footer" class="config"><br>
            <label>
                Add custom assets:
                <input type="file" id="loadAsset">
            </label>
            <table>
                <thead>
                    <tr>
                        <th></th>
                        <th>ID</th>
                        <th>Data</th>
                    </tr>
                </thead>
                <tbody id="assets" class="config">
                </tbody>
            </table>
            <button id="apply">Save & Apply These Settings</button>
        </div>
    </div>
    <div hidden id="templates">
        <table>
            <tr id="asset">
                <td><button id="removeButton">remove</button></td>
                <td id="label"></td>
                <td id="data"></td>
            </tr>
        </table>
        <li id="command">
            <button id="removeButton">remove</button>
            <span></span>
        </li>
        <li draggable="true" id="history" class="filter">
            <button id="removeButton">remove</button>
            Avoid previously played clips
            <label>
                <input type="checkbox" id="keepHistory" class="filterprop preconfig">
                keep history across sessions
            </label>
        </li>
        <li draggable="true" id="category" class="filter">
            <button id="removeButton">remove</button>
            Prefer a streaming category
            <select id="mode" class="filterProp">
                <option value="self">My category</option>
                <option value="target">The target's category</option>
            </select>
        </li>
        <li draggable="true" id="length" class="filter">
            <button id="removeButton">remove</button>
            Prefer clips shorter than
            <input type="number" min="5" max="60" value="30" id="time" class="filterProp preconfig">
            seconds
            <label>
                <input type="checkbox" id="cut" class="filterprop preconfig">
                Cut off longer clips
            </label>
        </li>
        <li draggable="true" id="single" class="filter">
            <button id="removeButton">remove</button>
            Select a single clip
            <select id="mode" class="filterProp">
                <option value="random">randomly</option>
                <option value="views">with the most views</option>
            </select>
        </li>
    </div>
    <style>
        textarea,
        #header,
        #footer {
            width: 365;
        }

        th,
        td {
            word-wrap: break-word;
            max-width: 365;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }

        filter {
            cursor: grab;
        }

        filter:active {
            cursor: grabbing;
        }

        .dragTarget {
            border-top: 1px solid black;
        }
    </style>
    <script src="https://cdn.jsdelivr.net/npm/obs-websocket-js@5.0.2/dist/obs-ws.min.js"
        integrity="sha256-h/nnsIkJJZMNu08xQJBMuUvcrgcUj1YlTYmoA0q4Ep8=" crossorigin="anonymous">
        </script>
    <script src="https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.js"
        integrity="sha256-4uG+XCLT8VsLieZ20+7elGRFKZltmJimsVh8mQinhQY=" crossorigin="anonymous">
        </script>
    <script type="module">
        const status = document.querySelector('#status')
        const hashParams = Object.fromEntries(new URLSearchParams(location.hash.substring(1)))
        if (!('access_token' in hashParams)) {
            const twitchAuth = document.querySelector('#twitchAuth')
            const url = new URL('https://id.twitch.tv/oauth2/authorize')
            url.search = new URLSearchParams({
                client_id: '72wtxvzs6erokrj33lk105whmoo381',
                response_type: 'token',
                scope: 'chat:read chat:edit moderation:read'
            })
            url.href += '&redirect_uri=' + location.origin + location.pathname
            twitchAuth.onclick = async function () {
                location.assign(url)
            }
            status.hidden = true
            twitchAuth.hidden = false
            throw 'Error: Twitch Auth Required'
        }

        const searchParams = Object.fromEntries(new URLSearchParams(location.search))
        if (searchParams['userChoice'] != 'allow') {
            const obsAuth = document.querySelector('#obsAuth')
            const url = new URL('https://sugoidogo.github.io/obsconnect')
            url.search = new URLSearchParams({ redirect_uri: location.href })
            obsAuth.onclick = async function () {
                location.assign(url)
            }
            status.hidden = true
            obsAuth.hidden = false
            throw 'Error: OBS Auth Required'
        }

        const obs = new OBSWebSocket()
        obs.addListener('ConnectionClosed', async function onConnectionClosed(error) {
            status.hidden = false
            status.innerText = 'OBS Code ' + error.code + ': ' + error.message
        })
        const inputKind = 'browser_source'
        const getSceneList = () => obs.call('GetSceneList', {}).then(onGetSceneList)
        const getInputList = () => obs.call('GetInputList', { inputKind: inputKind }).then(onGetInputList)
        document.querySelector('#refreshScenes').onclick = getSceneList
        document.querySelector('#refreshInputs').onclick = getInputList
        obs.addListener('Identified', async function onIdentified() {
            getSceneList()
            getInputList()
            obs.call('SetPersistentData', {
                realm: 'OBS_WEBSOCKET_DATA_REALM_GLOBAL',
                slotName: dataPrefix + 'access_token',
                slotValue: hashParams['access_token']
            })
        })
        const sceneSelect = document.querySelector('#sceneSelect')
        async function onGetSceneList(response) {
            console.debug('onGetSceneList', response)
            while (sceneSelect.hasChildNodes()) {
                sceneSelect.childNodes[0].remove()
            }
            for (const scene of response['scenes']) {
                const option = document.createElement('option')
                option.innerText = scene['sceneName']
                sceneSelect.appendChild(option)
            }
        }

        let inputs = []
        async function onGetInputList(response) {
            console.debug('onGetInputList', response)
            const requestBatch = []
            inputs = response['inputs']
            for (const input of inputs) {
                requestBatch.push({
                    requestType: 'GetInputSettings',
                    requestData: {
                        inputName: input['inputName']
                    }
                })
            }
            return obs.callBatch(requestBatch).then(onGetInputSettings)
        }
        const instanceSelect = document.querySelector('#instance')
        async function onGetInputSettings(response) {
            console.debug('onGetInputSettings', response)
            while (instanceSelect.hasChildNodes()) {
                instanceSelect.childNodes[0].remove()
            }
            inputs = inputs.filter(function (input, index) {
                const inputSettings = response[index]['responseData']['inputSettings']
                if ('url' in inputSettings && inputSettings['url'].startsWith(location.origin + location.pathname)) {
                    Object.assign(input, inputSettings)
                    const option = document.createElement('option')
                    option.innerText = input['inputName']
                    option.value = input['inputName']
                    instanceSelect.appendChild(option)
                    return true
                }
                return false
            })
            console.debug('onGetInputSettings', 'inputs.filter', inputs)
            const option = document.createElement('option')
            option.innerText = 'Create New Instance'
            option.value = ''
            instanceSelect.appendChild(option)
            instanceSelect.onchange = onInstanceSelect
            const inputs2 = {}
            for (const input of inputs) {
                inputs2[input['inputName']] = input['inputSettings']
            }
            inputs = inputs2
            await onInstanceSelect()
            document.querySelector('#config').hidden = false
            status.hidden = true
        }
        const dataPrefix = 'clippy.v2.'
        document.querySelector('#instance').onchange = onInstanceSelect
        const templates = document.querySelector('#templates')

        let draggedElement = null

        async function onDragStart(event) {
            draggedElement = event.srcElement
        }

        async function onDragEnter(event) {
            event.preventDefault()
            event.dataTransfer.effectAllowed = "move";
            event.dataTransfer.dropEffect = "move";
            event.target.classList.add('dragTarget')
        }

        async function onDragOver(event) {
            event.preventDefault()
            event.dataTransfer.effectAllowed = "move";
            event.dataTransfer.dropEffect = "move";
        }

        async function onDragLeave(event) {
            event.target.classList.remove('dragTarget')
        }

        async function onDrop(event) {
            event.preventDefault()
            const target = event.target
            const parent = target.parentElement
            parent.insertBefore(draggedElement, target)
            event.target.classList.remove('dragTarget')
            draggedElement = null
        }

        async function addFilter(...filters) {
            if (filters.length == 0) {
                const filterSelector = document.querySelector('#filterSelector')
                filters.push({ type: filterSelector.value })
            }
            console.debug('addFilter', filters)
            const filterList = document.querySelector('#filters')
            for (const filter of filters) {
                console.debug('addFilter', filter)
                const filterElement = templates.querySelector('#' + filter.type).cloneNode(true)
                filterElement.innerHTML = filterElement.innerHTML.replaceAll('preconfig', 'config')
                filterElement.querySelector('#removeButton').onclick = () => filterElement.remove()
                filterElement.ondragstart = onDragStart
                filterElement.ondragenter = onDragEnter
                filterElement.ondragover = onDragOver
                filterElement.ondragleave = onDragLeave
                filterElement.ondrop = onDrop
                delete filter.type
                for (const [arg, value] of Object.entries(filter)) {
                    const element = filterElement.querySelector('#' + arg)
                    switch (element.type) {
                        case 'checkbox':
                            element.checked = value
                            break
                        default:
                            element.value = value
                            break
                    }
                }
                filterList.appendChild(filterElement)
            }
        }
        document.querySelector('#addFilter').onclick = () => addFilter()


        async function addNewCommand(...commands) {
            console.debug('addNewCommand', commands)
            if (commands.length == 0) {
                const newCommand = document.getElementById('newCommand')
                commands.push(newCommand.value)
                newCommand.value = ''
            }
            const commandList = document.querySelector('#commands')
            for (const command of commands) {
                const commandElement = templates.querySelector('#command').cloneNode(true)
                commandElement.querySelector('#removeButton').onclick = () => commandElement.remove()
                commandElement.querySelector('span').innerText = command
                commandList.appendChild(commandElement)
            }
        }
        document.getElementById('addNewCommand').onclick = () => addNewCommand()

        const zipHeader = 'data:application/zip;base64,'

        function dataURL(blob) {
            return new Promise(function (resolve, reject) {
                const fileReader = new FileReader();
                fileReader.onabort = (event) => reject(event)
                fileReader.onerror = (event) => reject(event)
                fileReader.onload = (event) => resolve(event.target.result)
                fileReader.readAsDataURL(blob);
            });
        }

        async function loadZip(zipDataURL) {
            JSZip.loadAsync(zipDataURL.substring(zipHeader.length), { base64: true })
                .then(zip => {
                    for (const [path, entry] of Object.entries(zip.files)) {
                        entry.async('blob').then(blob => {
                            loadAsset(new File([blob], path))
                        })
                    }
                })
        }

        async function loadAsset(assets) {
            status.hidden = false
            if (assets instanceof File) {
                console.debug('loadAsset', assets)
                const label = assets.name.split('/').at(-1).split('.')[0]
                const data = await dataURL(assets)
                if (data.startsWith(zipHeader)) {
                    return loadZip(data)
                }
                assets = {}
                assets[label] = data
            }
            console.debug('loadAsset', assets)
            const assetList = document.querySelector('#assets')
            for (const [label, data] of Object.entries(assets)) {
                const listItem = templates.querySelector('#asset').cloneNode(true)
                listItem.querySelector('#removeButton').onclick = () => listItem.remove()
                listItem.querySelector('#label').innerText = label
                listItem.querySelector('#data').innerText = data
                assetList.appendChild(listItem)
            }
            status.hidden = true
        }
        document.querySelector('#loadAsset').oninput = (event) => loadAsset(event.target.files[0])

        async function onInstanceSelect(configData = null) {
            const name = instanceSelect.value
            const newConfig = document.querySelector('#new')
            const config = document.querySelector('#existing')
            if (name == '') {
                newConfig.hidden = false
                config.hidden = true
                return
            }
            if (configData == null || !('autoplay' in configData)) {
                configData = await obs.call('GetPersistentData', {
                    realm: 'OBS_WEBSOCKET_DATA_REALM_GLOBAL',
                    slotName: dataPrefix + name
                })
                console.debug('onInstanceSelect', 'GetPersistentData', configData)
            }
            if ('slotValue' in configData) {
                configData = configData['slotValue']
            }
            console.debug('onInstanceSelect', configData)
            if (Object.entries(configData).length == 0) {
                document.querySelector('option[value=' + name + ']').remove()
                return onInstanceSelect()
            }
            for (const [id, value] of Object.entries(configData)) {
                const element = document.getElementById(id)
                if (element == null) {
                    console.warn('unused config entry', id, value)
                    continue
                }
                while (element.hasChildNodes()) {
                    element.childNodes[0].remove()
                }
                switch (element.tagName.toLowerCase()) {
                    case 'input':
                        switch (element.type) {
                            case 'checkbox':
                                element.checked = value
                                break
                            default:
                                element.value = value
                                break
                        }
                        break;
                    case 'textarea':
                        element.value = value
                        break
                    case 'ol':
                        addFilter(...value)
                        break
                    case 'ul':
                        addNewCommand(...value)
                        break
                    case 'tbody':
                        loadAsset(value)
                        break
                    default:
                        console.warn('unknown config item', id, value)
                        break
                }
            }
            config.hidden = false
            newConfig.hidden = true
        }

        const inputOBSURL = new URL(searchParams['obsurl'])
        inputOBSURL.host = 'localhost'
        const defaultConfig = {
            "autoplay": false,
            "autoso": false,
            "commands": [
                "!so",
                "!shoutout"
            ],
            "messageOn": false,
            "message": "Check out display_name: description https://twitch.tv/login",
            "first": 20,
            "filters": [
                {
                    "type": "history",
                    "keepHistory": true
                },
                {
                    "type": "single",
                    "mode": "views"
                }
            ],
            "keepHistory": true,
            "time": 30,
            "cut": false,
            "header": "Check out broadcaster_name",
            "footer": "'title' by creator_name",
            "assets": {}
        }
        fetch('css/twitchyLoader.css')
            .then((response) => response.blob())
            .then((blob) => dataURL(blob))
            .then(dataURL => defaultConfig.assets['TwitchyTV'] = dataURL)
            .then(() => console.debug('default config', defaultConfig))

        document.querySelector('#createNewInstance').onclick = async function createNewInstance() {
            const inputName = document.querySelector('#name').value
            const sceneName = sceneSelect.value
            const url = new URL(location.origin + location.pathname + 'overlay.html')
            url.search = new URLSearchParams({
                obsurl: inputOBSURL.href,
                obspassword: searchParams['obspassword'],
                inputName: inputName
            })
            obs.call('CreateInput', {
                sceneName: sceneName,
                inputName: inputName,
                inputKind: inputKind,
                inputSettings: {
                    height: 1080,
                    width: 1920,
                    url: url.href
                }
            }).then(async function onCreateInput() {
                obs.call('SetPersistentData', {
                    realm: 'OBS_WEBSOCKET_DATA_REALM_GLOBAL',
                    slotName: dataPrefix + inputName,
                    slotValue: defaultConfig
                })
            }).then(async function onSetPersistentData() {
                const option = document.createElement('option')
                option.innerText = inputName
                instanceSelect.appendChild(option)
                instanceSelect.value = inputName
                onInstanceSelect(defaultConfig)
            }).catch(error => window.alert(error))
        }
        document.querySelector('#deleteInstance').onclick = async function deleteInstance() {
            const inputName = instanceSelect.value
            obs.callBatch([
                {
                    requestType: 'SetPersistentData',
                    requestData: {
                        realm: 'OBS_WEBSOCKET_DATA_REALM_GLOBAL',
                        slotName: dataPrefix + inputName,
                        slotValue: {}
                    }
                },
                {
                    requestType: 'SetPersistentData',
                    requestData: {
                        realm: 'OBS_WEBSOCKET_DATA_REALM_GLOBAL',
                        slotName: dataPrefix + inputName + '.history',
                        slotValue: {}
                    }
                },
                {
                    requestType: 'RemoveInput',
                    requestData: {
                        inputName: inputName
                    }
                }
            ]).then((response) => console.debug('deleteInstance', response))
            const index = instanceSelect.selectedIndex
            instanceSelect.remove(index)
            onInstanceSelect()
        }
        function getElementValue(input) {
            switch (input.type) {
                case 'number':
                    return parseInt(input.value)
                case 'checkbox':
                    return input.checked
                default:
                    return input.value
            }
        }
        document.querySelector('#apply').onclick = async function apply() {
            const config = {}
            for (const element of document.querySelectorAll('.config')) {
                switch (element.tagName.toLowerCase()) {
                    case 'textarea':
                    case 'input':
                        config[element.id] = getElementValue(element)
                        break
                    case 'ul':
                        const commands = []
                        for (const span of element.querySelectorAll('span')) {
                            commands.push(span.innerText)
                        }
                        config[element.id] = commands
                        break
                    case 'ol':
                        const filters = []
                        for (const filterElement of element.querySelectorAll('.filter')) {
                            const filter = {}
                            filter['type'] = filterElement.id
                            for (const propElement of filterElement.querySelectorAll('.filterProp')) {
                                filter[propElement.id] = getElementValue(propElement)
                            }
                            filters.push(filter)
                        }
                        config[element.id] = filters
                        break
                    case 'tbody':
                        const assets = {}
                        for (const assetElement of element.querySelectorAll('tr')) {
                            const label = assetElement.querySelector('#label').innerText
                            const data = assetElement.querySelector('#data').innerText
                            assets[label] = data
                        }
                        config[element.id] = assets
                        break
                    default:
                        console.log('Unknown config element', element)
                        break
                }
            }
            console.debug('apply', config)
            obs.call('SetPersistentData', {
                realm: 'OBS_WEBSOCKET_DATA_REALM_GLOBAL',
                slotName: dataPrefix + instanceSelect.value,
                slotValue: config
            })
        }

        obs.connect(searchParams['obsurl'], searchParams['obspassword'])
    </script>