<body>
    <header>
        <img>
        <h1>Clippy is Loading</h1>
    </header>
    <video autoplay></video>
    <footer><h2>This message should disappear shortly</h2></footer>
</body>
<style>
    body {
        overflow: hidden;
        margin: 0px;
    }
    header{
        position: absolute;
        top: 0px;
        left: 0px;
        right: 0px;
    }
    footer{
        position: absolute;
        bottom: 0px;
        left: 0px;
        right: 0px;
    }
    header,footer{
        display: flex;
        align-items: center;
    }
    footer{
        justify-content: center;
    }
    h1,h2 {
        font-size: 10vh;
        margin-block-start: 0px;
        margin-block-end: 0px;
        white-space: nowrap;
    }
    img{
        height: 10vh;
        border-radius: 50%;
        display: inline;
    }
    video {
        width: 100vw;
        height: 100vh;
        object-fit: contain;
    }
</style>
<script type="module">
    import localforage from 'https://unpkg.com/localforage/src/localforage.js'
    import fontScale from '../js-util/fontScale.mjs'
    import loadAsset from '../js-util/AssetLoader.mjs'
    import FileReaderAsync from '../js-util/FileReaderAsync.mjs'
    const config_name=new URLSearchParams(location.search).get('name')
    const localStorage=localforage.createInstance({name:'clippy.v2'})
    const video=document.querySelector('video')
    const img=document.querySelector('img')
    const header=document.querySelector('h1')
    const footer=document.querySelector('h2')
    const body=document.querySelector('body')
    const maxFontSize=parseInt(getComputedStyle(header).fontSize)
    const auth_headers={}
    const queue=[]
    let mods=[]
    let history=[]
    let config=undefined
    let irc=undefined
    let broadcaster=undefined
    let cut=undefined
    let keepHistory=undefined
    let tid=undefined
    let consent=JSON.parse(window.localStorage.getItem('consent'))||[]
    //import getUserChannelInfo from './getUserChannelInfo.js'
    // fill variables in a string using bash variable notation
    function fillVars(string,vars,prefix='$'){
        for(const [key,val] of Object.entries(vars)){
            string=string.replaceAll(prefix+key,val)
        }
        return string
    }
    // load the next clip from the queue
    async function loadNextClip(){
        clearTimeout(tid)
        const clip=queue.shift()
        if(clip==undefined){
            if('auto' in config){
                shoutout(broadcaster.login)
            }else{        
                video.pause()
                body.style.opacity=0
            }
            return
        }
        console.debug(clip)
        if('headerImg' in config){
            img.src=clip.profile_image_url
        }
        if('header' in config){
            header.innerHTML=fillVars(config.headerText,clip)
            await fontScale(header,maxFontSize)
        }
        if('footer' in config){
            footer.innerHTML=fillVars(config.footerText,clip)
            await fontScale(footer,maxFontSize)
        }
        video.src=clip.video_url
        history.push(clip.id)
        if(keepHistory){
            window.localStorage.setItem('history',JSON.stringify(history))
        }
    }
    // apply a clip filter
    function applyFilter(clips, filter, target) {
        let newClips = []
        switch (filter.type) {
            case 'history':
                if('keepHistory' in filter){
                    keepHistory=true
                    history=JSON.parse(window.localStorage.getItem('history'))
                    if(!(history instanceof Array)){
                        history=[]
                    }
                }
                newClips = clips.filter(clip => !history.includes(clip.id))
                if(newClips.length==0){
                    let index=history.length
                    for(const clip of clips){
                        if(history.indexOf(clip.id)<index){
                            index=history.indexOf(clip.id)
                        }
                    }
                    history.splice(index,1)
                    newClips = clips.filter(clip => !history.includes(clip.id))
                }
                break
            case 'category':
                let game_id = 0
                switch (filter.mode) {
                    case 'self':
                        game_id = broadcaster.game_id
                        break
                    case 'target':
                        game_id = target.game_id
                        break
                }
                newClips = clips.filter(clip => clip.game_id == game_id)
                break
            case 'duration':
                cut=filter.cut
                newClips = clips.filter(clip => filter.min <= clip.duration <= filter.max)
                break
            case 'single':
                switch (filter.mode) {
                    case 'views':
                        let view_count = 0
                        for (const clip of clips) {
                            if (clip.view_count > view_count) {
                                view_count = clip.view_count
                            }
                        }
                        clips = clips.filter(clip => clip.view_count >= view_count)
                    case 'random':
                        const index = Math.floor(Math.random() * clips.length)
                        newClips.push(clips[index])
                        break
                }
                break
        }
        console.debug('filter result:',filter.type,newClips)
        if (newClips.length == 0) {
            return clips
        } else {
            return newClips
        }
    }
    // collect user and channel vars
    function getUserChannelInfo(login=undefined){
        let userChannelInfo={}
        let url=new URL('https://api.twitch.tv/helix/users')
        if(login){
            url.searchParams.append('login',login)
        }
        return fetch(url,{headers:auth_headers})
        .then((response)=>response.json())
        .then(function(json){
            userChannelInfo=json.data[0]
            url=new URL('https://api.twitch.tv/helix/channels')
            url.searchParams.append('broadcaster_id',userChannelInfo.id)
            return fetch(url,{headers:auth_headers})
        }).then((response)=>response.json())
        .then(function(json){
            const channelInfo=json.data[0]
            userChannelInfo.game_id=channelInfo.game_id
            userChannelInfo.game_name=channelInfo.game_name
            userChannelInfo.title=channelInfo.title
            userChannelInfo.delay=channelInfo.delay
            userChannelInfo.command=config.commands[0]
            return userChannelInfo
        })
    }
    function getClipByID(id){
        const url=new URL('https://api.twitch.tv/helix/clips')
        url.searchParams.append('id',id)
        return fetch(url,{headers:auth_headers})
        .then(response=>response.json())
        .then(json=>json.data[0])
    }
    // send a raw irc message
    window.IRCSend=function(message){
        console.debug('< '+message)
        irc.send(message)
    }
    // send a chat message in the broadcaster's channel
    window.IRCSendChat=function(message){
        IRCSend('PRIVMSG #' + broadcaster.login + ' :' + message)
    }
    // play one or more clips from one or more twitch channels
    window.shoutout=async function(...targets){
        console.debug('shoutout',targets)
        broadcaster=await getUserChannelInfo()
        for(let target of targets){
            if(target[0]==='@'){
                target=target.substring(1)
            }
            //target=target.toLowerCase()
            if(target.startsWith('https://')){
                target=target.split('/').at(-1)
                console.debug(target)
                let clip=await getClipByID(target)
                target=await getUserChannelInfo(clip.broadcaster_name)
                if('message' in config){
                    IRCSendChat(fillVars(config.messageText,target))
                }
                clip.profile_image_url=target.profile_image_url
                clip.video_url=clip.thumbnail_url.replace(/-preview-.*/g,'.mp4')
                queue.push(clip)
                if(video.paused){
                    loadNextClip()
                }
                return [clip]
            }
            return getUserChannelInfo(target)
            .then(async function(userChannelInfo){
                target=userChannelInfo
                if('message' in config){
                    IRCSendChat(fillVars(config.messageText,target))
                }
                if(!consent.includes(target.login)){
                    const text=fillVars(config.consentText,target)
                    IRCSendChat(text)
                    return false
                }
                const url=new URL('https://api.twitch.tv/helix/clips')
                url.search=new URLSearchParams({
                    'broadcaster_id':target.id,
                    'first':config.first
                })
                return fetch(url,{headers:auth_headers})
            })
            .then(async function(response){
                if(!response){
                    return 'user has not given consent to use their clips'
                }
                const json=await response.json()
                let clips=json.data
                if('filters' in config){
                    for(const filter of config.filters){
                        clips=applyFilter(clips,filter,target)
                    }
                }
                for(const clip of clips){
                    clip.profile_image_url=target.profile_image_url
                    clip.video_url=clip.thumbnail_url.replace(/-preview-.*/g,'.mp4')
                }
                queue.push(...clips)
                console.debug(video.src)
                if(video.paused){
                    loadNextClip()
                }
                return clips
            })
        }
    }
    video.onended=loadNextClip
    video.onplay=function(){
        body.style.opacity=1
        if(cut){
            console.debug('cut',cut)
            tid=setTimeout(video.onended,cut*1000)
        }
    }
    // read config
    try {
        config=JSON.parse(decodeURIComponent(location.hash.substring(1))) || await localStorage.getItem(config_name)
        localStorage.setItem(config_name,config)
    } catch {
        config=await localStorage.getItem(config_name)
    }
    for(const list_name of ['commands','assets','filters']){
        if(!(config[list_name] instanceof Array)){
            config[list_name]=[config[list_name]]
        }
    }
    if(!config.consentText){
        config.consentText=await fetch('default.json').then(response=>response.json()).then(json=>json.consentText)
    }
    // read access_token after returning from js-util/auth-return
    config.access_token=new URLSearchParams(location.hash.substring(1)).get('access_token') || config.access_token
    console.debug(config)
    // verify access_token
    fetch('https://id.twitch.tv/oauth2/validate',{headers:{'Authorization':'OAuth '+config.access_token}})
    // populate auth_header from response, and use it to get broadcaster info
    .then(async function(response){
        const json=await response.json()
        auth_headers['Authorization']='Bearer '+config.access_token
        auth_headers['Client-Id']=json.client_id
        return fetch('https://api.twitch.tv/helix/users',{headers:auth_headers})
    })
    // store broadcaster info and set up IRC
    .then(async function(response){
        const json=await response.json()
        broadcaster=json.data[0]
        consent.push(broadcaster.login)
        if(config['img']){
            await fetch(broadcaster.profile_image_url,{mode:'no-cors'})
            img.src=broadcaster.profile_image_url
        }else{
            img.hidden=true
        }
        if(config['header']){
            await fontScale(header)
        }else{
            header.hidden=true
        }
        if(config['footer']){
            await fontScale(footer)
        }else{
            footer.hidden=true
        }
        body.style.opacity=0
        irc=new WebSocket('wss://irc-ws.chat.twitch.tv:443')
        irc.onopen=function(){
            IRCSend('PASS oauth:' + config.access_token)
            IRCSend('NICK ' + broadcaster.login)
            IRCSend('JOIN #' + broadcaster.login)
            IRCSend('CAP REQ :twitch.tv/tags twitch.tv/commands')    
            if('auto' in config){
                shoutout(broadcaster.login)
            }
        }
        irc.onerror=function(error){
            alert('Clippy lost connection to twitch, please reload. '+error.code+" "+error.reason)
            throw error
        }
        irc.onclose=irc.onerror
        irc.onmessage=function(event){
            console.debug('> '+event.data)
            for(const message of event.data.split('\r\n')){
                if(message==''){
                    continue
                }
                const [tags,prefix,data] = message.split(':')
                //console.debug(tags,prefix,data)
                if(tags=='PING '){
                    return IRCSend('PONG :'+prefix)
                }
                if('raid' in config && tags.includes('msg-id=raid')){
                    return shoutout(tags.split('msg-param-login=').at(-1).split(';')[0])
                }
                if(data==undefined){
                    continue
                }
                if('command' in config && config.commands.includes(data.split(' ')[0])){
                    const login=prefix.split('!')[0]
                    console.debug(login+':'+data)
                    if(data.split(' ')[1]=='consent'){
                        consent.push(login)
                        window.localStorage.setItem('consent',JSON.stringify(consent))
                        return IRCSendChat(login+', Thank you for your consent!')
                    }
                    if(tags.includes('badges=broadcaster') || tags.includes('mod=1')){
                        const targets=data.split(' ')
                        targets.shift()
                        return shoutout(...targets)
                    }
                }
            }
        }
    })
    // get a new access token if previous steps fail
    .catch(function(error){
        alert('An error ocurred during clippy startup: '+Object.entries(error))
        if(!confirm('Would you like clippy to try getting a new access token? If this message repeats itself, make an issue report instead.')){
            throw error
        }
        const auth_url=new URL('https://id.twitch.tv/oauth2/authorize')
        auth_url.search=new URLSearchParams({
            'client_id':'72wtxvzs6erokrj33lk105whmoo381',
            'response_type':'token',
            'scope':'chat:read chat:edit'
        }).toString()+'&redirect_uri=https://sugoidogo.github.io/js-util/auth-return.html'
        const url=new URL('https://sugoidogo.github.io/js-util/auth-return.html')
        url.search=new URLSearchParams({
            'redirect_uri':location.origin+location.pathname+location.search,
            'target':auth_url.href
        })
        location.assign(url)
    })

    if('assets' in config){
        for(const asset of config.assets){
            if(!asset.data.startsWith('data:')){
                asset.data=await FileReaderAsync.readAs('DataURL',(await(await fetch(url,{cache:'no-cache'})).blob()))
            }
            loadAsset(asset.data,asset.filename,true)
        }
    }

</script>